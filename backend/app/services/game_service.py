from firebase_admin import firestore
from app.services.firebase_service import get_firestore_client
from app.models.game import CreateGameRequest
import datetime
import random
import uuid
from collections import Counter

def create_game(host_uid: str, settings: CreateGameRequest) -> str:
    """
    Creates a new game room in Firestore.

    Args:
        host_uid: The UID of the user creating the game.
        settings: A Pydantic model containing the game settings.

    Returns:
        The ID of the newly created game document.
    """
    db = get_firestore_client()
    
    # Generate a random name for the host for this game.
    # In a real implementation, this would come from a helper function.
    host_game_name = "Clever Cat" # Placeholder

    # Define the initial structure of the game document using the Pydantic model
    new_game_data = {
        "hostId": host_uid,
        "status": "waiting",
        "language": settings.language,
        "aiCount": settings.aiCount,
        "privacy": settings.privacy,
        "createdAt": firestore.SERVER_TIMESTAMP,
        "currentRound": 0,
        "rounds": [],
        "players": [
            {
                "uid": host_uid,
                "gameDisplayName": host_game_name,
                "isImpostor": False # Host is always human
            }
        ],
        "readyPlayerIds": [],
        "votes": []
    }

    # Add the new document to the 'game_rooms' collection
    # The ID is automatically generated by Firestore.
    _, game_ref = db.collection("game_rooms").add(new_game_data)
    
    return game_ref.id

def list_public_games():
    """
    Retrieves a list of public games that are waiting for players.

    Returns:
        A list of dictionaries, where each dictionary represents a public game.
    """
    db = get_firestore_client()
    
    games_ref = db.collection("game_rooms")
    
    # Create a query to find public games in the "waiting" state.
    query = games_ref.where("privacy", "==", "public").where("status", "==", "waiting")
    
    public_games = []
    for game in query.stream():
        game_data = game.to_dict()
        public_games.append({
            "gameId": game.id,
            "language": game_data.get("language"),
            "playerCount": len(game_data.get("players", [])),
            "maxPlayers": 4 # As per our game rules
        })
        
    return public_games

def join_game(game_id: str, user_uid: str):
    """
    Adds a player to a game room in Firestore.

    Args:
        game_id: The ID of the game to join.
        user_uid: The UID of the user joining the game.

    Raises:
        ValueError: If the game is full, not found, not waiting for players,
                    or if the player has already joined.
    """
    db = get_firestore_client()
    game_ref = db.collection("game_rooms").document(game_id)
    game_doc = game_ref.get()

    if not game_doc.exists:
        raise ValueError("Game not found.")

    game_data = game_doc.to_dict()
    players = game_data.get("players", [])

    if game_data.get("status") != "waiting":
        raise ValueError("This game is not waiting for players.")

    if len(players) >= 4:
        raise ValueError("This game is full.")

    if any(p["uid"] == user_uid for p in players):
        raise ValueError("You have already joined this game.")

    # In a real implementation, this would come from a helper function.
    new_player_name = "Witty Walrus" # Placeholder

    new_player = {
        "uid": user_uid,
        "gameDisplayName": new_player_name,
        "isImpostor": False # Impostor status is assigned when the game starts
    }

    # Atomically add the new player to the 'players' array.
    game_ref.update({
        "players": firestore.ArrayUnion([new_player])
    })

def start_game(game_id: str, user_uid: str):
    """
    Starts the game, assigns impostors, and updates the game state.

    Args:
        game_id: The ID of the game to start.
        user_uid: The UID of the user attempting to start the game.

    Raises:
        ValueError: If the user is not the host, if there are not enough players,
                    or if the game is not in a 'waiting' state.
    """
    db = get_firestore_client()
    game_ref = db.collection("game_rooms").document(game_id)
    game_doc = game_ref.get()

    if not game_doc.exists:
        raise ValueError("Game not found.")

    game_data = game_doc.to_dict()

    if game_data.get("hostId") != user_uid:
        raise ValueError("Only the host can start the game.")

    if game_data.get("status") != "waiting":
        raise ValueError("The game has already started or is finished.")

    players = game_data.get("players", [])
    # For now, we will not require a minimum number of players to start the game.
    # if len(players) < 2:
        # raise ValueError("Not enough players to start the game (minimum 2).")

    ai_count = game_data.get("aiCount", 0)

    # Ensure all human players are marked as not impostors.
    for player in players:
        player['isImpostor'] = False

    # Create AI player objects and mark them as impostors.
    # In a real implementation, names would be generated dynamically.
    ai_players = []
    for _ in range(ai_count):
        ai_players.append({
            "uid": f"ai_{uuid.uuid4()}",
            "gameDisplayName": "Witty Walrus", # Placeholder
            "isImpostor": True
        })

    # Combine human and AI players into a single list of all participants.
    all_participants = players + ai_players

    # Shuffle the list to randomize player order for the frontend.
    random.shuffle(all_participants)
    
    # Set timers for the first round
    now = datetime.datetime.now(datetime.timezone.utc)
    # Using a short duration for easier testing; this would be longer in production.
    answer_duration = datetime.timedelta(minutes=1) 
    end_time = now + answer_duration

    game_ref.update({
        "players": all_participants,
        "status": "in_progress",
        "roundPhase": "ANSWER_SUBMISSION", # Add the new granular state
        "currentRound": 1, # Start the first round
        "roundStartTime": now,
        "roundEndTime": end_time
    })

def tally_answers(game_id: str):
    """
    Transitions the game from ANSWER_SUBMISSION to VOTING.
    This is triggered by a client after the round timer expires. The function
    validates the time, moves pending messages to the main messages collection,
    and sets up the timer for the voting phase.
    """
    db = get_firestore_client()
    game_ref = db.collection("game_rooms").document(game_id)

    @firestore.transactional
    def _tally_answers_in_transaction(transaction, game_ref):
        game_doc = game_ref.get(transaction=transaction)
        if not game_doc.exists:
            raise ValueError("Game not found.")

        game_data = game_doc.to_dict()

        # --- Validation ---
        if game_data.get("status") != "in_progress":
            raise ValueError("This game is not currently in progress.")
        
        # This check makes the function idempotent. If it's already been tallied, do nothing.
        if game_data.get("roundPhase") != "ANSWER_SUBMISSION":
            return
            
        # Server-side time validation
        round_end_time = game_data.get("roundEndTime")
        if round_end_time and datetime.datetime.now(datetime.timezone.utc) < round_end_time.replace(tzinfo=datetime.timezone.utc):
            raise ValueError("Answer submission time has not ended yet.")

        # --- Logic ---
        pending_messages_ref = game_ref.collection("pending_messages")
        pending_messages = list(pending_messages_ref.stream(transaction=transaction))

        messages_ref = game_ref.collection("messages")
        
        for msg in pending_messages:
            transaction.set(messages_ref.document(msg.id), msg.to_dict())
            transaction.delete(msg.reference)

        # --- State Transition ---
        now = datetime.datetime.now(datetime.timezone.utc)
        current_round = game_data.get("currentRound", 0)

        # If it's the end of Round 1, skip voting and go to Round 2 answers
        if current_round == 1:
            answer_duration = datetime.timedelta(minutes=1)
            next_round_end_time = now + answer_duration
            transaction.update(game_ref, {
                "roundPhase": "ANSWER_SUBMISSION",
                "currentRound": current_round + 1,
                "roundStartTime": now,
                "roundEndTime": next_round_end_time
            })
        else: # For Rounds 2 and 3, proceed to voting
            vote_duration = datetime.timedelta(seconds=90)
            vote_end_time = now + vote_duration
            
            transaction.update(game_ref, {
                "roundPhase": "VOTING",
                "roundStartTime": now,
                "roundEndTime": vote_end_time
            })

    transaction = db.transaction()
    _tally_answers_in_transaction(transaction, game_ref)
    
def tally_votes(game_id: str):
    """
    Counts votes, processes eliminations, checks for win/loss conditions,
    and advances the game state.
    """
    db = get_firestore_client()
    game_ref = db.collection("game_rooms").document(game_id)

    @firestore.transactional
    def _tally_votes_in_transaction(transaction, game_ref):
        game_doc = game_ref.get(transaction=transaction)
        if not game_doc.exists:
            raise ValueError("Game not found.")

        game_data = game_doc.to_dict()

        # --- Validation ---
        if game_data.get("status") != "in_progress":
            raise ValueError("This game is not currently in progress.")
        
        if game_data.get("roundPhase") != "VOTING":
            return # Idempotency check

        # Server-side time validation
        round_end_time = game_data.get("roundEndTime")
        if round_end_time and datetime.datetime.now(datetime.timezone.utc) < round_end_time.replace(tzinfo=datetime.timezone.utc):
            raise ValueError("Voting time has not ended yet.")

        # --- Vote Counting ---
        current_round = game_data.get("currentRound", 0)
        votes_this_round = [v for v in game_data.get("votes", []) if v.get("round") == current_round]
        
        if not votes_this_round:
            # If no one voted, proceed to the next round without elimination
            pass
        else:
            vote_counts = Counter(v["targetId"] for v in votes_this_round)
            most_votes = vote_counts.most_common(2)
            
            # Eliminate player only if there's no tie for the most votes
            if len(most_votes) == 1 or (len(most_votes) > 1 and most_votes[0][1] > most_votes[1][1]):
                player_to_eliminate_uid = most_votes[0][0]
                for player in game_data["players"]:
                    if player["uid"] == player_to_eliminate_uid:
                        player["isEliminated"] = True
                        break

        # --- Win/Loss Condition Check ---
        active_players = [p for p in game_data["players"] if not p.get("isEliminated")]
        active_impostors = [p for p in active_players if p.get("isImpostor")]
        active_humans = [p for p in active_players if not p.get("isImpostor")]

        update_payload = {}
        game_is_over = False
        if len(active_impostors) == 0:
            update_payload.update({"status": "finished", "roundPhase": "GAME_ENDED", "winner": "humans"})
            game_is_over = True
        elif len(active_impostors) >= len(active_humans):
            update_payload.update({"status": "finished", "roundPhase": "GAME_ENDED", "winner": "ai"})
            game_is_over = True
        elif current_round >= 3: # Max rounds reached
            update_payload.update({"status": "finished", "roundPhase": "GAME_ENDED", "winner": "ai"})
            game_is_over = True

        # --- State Transition ---
        if not game_is_over:
            now = datetime.datetime.now(datetime.timezone.utc)
            answer_duration = datetime.timedelta(minutes=1)
            next_round_end_time = now + answer_duration
            
            update_payload.update({
                "currentRound": current_round + 1,
                "roundPhase": "ANSWER_SUBMISSION",
                "roundStartTime": now,
                "roundEndTime": next_round_end_time
            })
        
        # Always update the players list in case of elimination
        update_payload["players"] = game_data["players"]
        transaction.update(game_ref, update_payload)

    transaction = db.transaction()
    _tally_votes_in_transaction(transaction, game_ref)

def submit_vote(game_id: str, voter_uid: str, target_uid: str):
    """
    Submits a player's vote for the current round.

    Args:
        game_id: The ID of the game.
        voter_uid: The UID of the player casting the vote.
        target_uid: The UID of the player being voted for.

    Raises:
        ValueError: If the game state is invalid for voting or the vote is invalid.
    """
    db = get_firestore_client()
    game_ref = db.collection("game_rooms").document(game_id)
    game_doc = game_ref.get()

    if not game_doc.exists:
        raise ValueError("Game not found.")

    game_data = game_doc.to_dict()

    # --- Validation ---
    if game_data.get("status") != "in_progress":
        raise ValueError("This game is not currently in progress.")
        
    if game_data.get("roundPhase") != "VOTING":
        raise ValueError("It is not currently time to vote.")

    if voter_uid == target_uid:
        raise ValueError("You cannot vote for yourself.")

    players = game_data.get("players", [])
    player_uids = {p["uid"] for p in players}
    if voter_uid not in player_uids:
        raise ValueError("You are not a player in this game.")
    if target_uid not in player_uids:
        raise ValueError("The targeted player is not in this game.")

    current_round = game_data.get("currentRound", 0)
    votes = game_data.get("votes", [])
    if any(v["voterId"] == voter_uid and v.get("round") == current_round for v in votes):
        raise ValueError("You have already voted in this round.")

    # --- Logic ---
    new_vote = {
        "voterId": voter_uid,
        "targetId": target_uid,
        "round": current_round
    }

    game_ref.update({
        "votes": firestore.ArrayUnion([new_vote])
    })

def submit_answer(game_id: str, user_uid: str, answer: str):
    """
    Submits a player's answer for the current round.

    Args:
        game_id: The ID of the game.
        user_uid: The UID of the player submitting the answer.
        answer: The text of the answer.

    Raises:
        ValueError: If the game state is invalid for submission or the
                    player is not eligible to submit.
    """
    db = get_firestore_client()
    game_ref = db.collection("game_rooms").document(game_id)
    game_doc = game_ref.get()

    if not game_doc.exists:
        raise ValueError("Game not found.")

    game_data = game_doc.to_dict()
    
    if game_data.get("status") != "in_progress":
        raise ValueError("This game is not currently in progress.")
        
    if game_data.get("roundPhase") != "ANSWER_SUBMISSION":
        raise ValueError("It is not currently time to submit answers.")
        
    players = game_data.get("players", [])
    if not any(p["uid"] == user_uid for p in players):
        raise ValueError("You are not a player in this game.")
        
    # Store the answer in the pending_messages subcollection
    pending_messages_ref = game_ref.collection("pending_messages")
    
    # Check if the player has already submitted an answer
    existing_answer_query = pending_messages_ref.where("authorId", "==", user_uid).limit(1).get()
    if existing_answer_query:
        raise ValueError("You have already submitted an answer for this round.")
        
    new_answer = {
        "authorId": user_uid,
        "content": answer,
        "submittedAt": firestore.SERVER_TIMESTAMP
    }
    
    pending_messages_ref.add(new_answer)
